{
    parserClass="at.jku.ssw.coco.intellij.parser.CocoParser"

    extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

    psiClassPrefix="Coco"
    psiImplClassSuffix="Impl"
    psiPackage="at.jku.ssw.coco.intellij.psi"
    psiImplPackage="at.jku.ssw.coco.intellij.psi.impl"

    elementTypeHolderClass="at.jku.ssw.coco.intellij.psi.CocoTypes"
    elementTypeClass="at.jku.ssw.coco.intellij.psi.CocoElementType"
    tokenTypeClass="at.jku.ssw.coco.intellij.psi.CocoTokenType"

    psiImplUtilClass="at.jku.ssw.coco.intellij.psi.impl.CocoPsiImplUtil"

    mixin("End|BasicSet|TokenFactor|Factor")="at.jku.ssw.coco.intellij.psi.impl.CocoReferencingType"
    implements("End")="at.jku.ssw.coco.intellij.psi.HasCocoCompilerReference"
    methods("End")=[getIdentText]
    implements("BasicSet|TokenFactor")="at.jku.ssw.coco.intellij.psi.HasCocoCharacterReference"
    methods("BasicSet|TokenFactor")=[getCharacterReferenceName getIdentText]
    implements("Factor")="at.jku.ssw.coco.intellij.psi.HasCocoTokenOrProductionReference"
    methods("Factor")=[getTokenReferenceName getProductionReferenceName getIdentText]


    mixin("Compiler|SetDecl|TokenDecl|Production")="at.jku.ssw.coco.intellij.psi.impl.CocoNamedElementImpl"
    implements("Compiler|SetDecl|TokenDecl|Production")="at.jku.ssw.coco.intellij.psi.CocoNamedElement"
    methods("SetDecl|TokenDecl|Production")=[getName setName getNameIdentifier getPresentation]
    methods("Compiler")=[getName setName getNameIdentifier getPresentation getTextOffset]

    tokens=[
        string='regexp:"(\\\\|\\"|[^\"\n])*"'
        char="regexp:'(\\u(\p{XDigit}{4})|\\.|.)'"

        WHITE_SPACE='regexp:\s+'
        LINE_COMMENT='regexp://.*'
        BLOCK_COMMENT='regexp:/\*([^\*]|\*+[^/\*])*\*+/'

        KEYWORD_ANY='ANY'
        KEYWORD_CHARACTERS='CHARACTERS'
        KEYWORD_COMPILER='COMPILER'
        KEYWORD_COMMENTS='COMMENTS'
        KEYWORD_CONTEXT='CONTEXT'
        KEYWORD_END='END'
        KEYWORD_FROM='FROM'
        KEYWORD_IF='IF'
        KEYWORD_IGNORE='IGNORE'
        KEYWORD_IGNORECASE='IGNORECASE'
        KEYWORD_IMPORT='import'
        KEYWORD_NESTED='NESTED'
        KEYWORD_OUT='out'
        KEYWORD_PRAGMAS='PRAGMAS'
        KEYWORD_PRODUCTIONS='PRODUCTIONS'
        KEYWORD_SYNC='SYNC'
        KEYWORD_TO='TO'
        KEYWORD_TOKENS='TOKENS'
        KEYWORD_WEAK='WEAK'

        TERMINATOR='.'
        PLUS='+'
        MINUS='-'
        RANGE='..'
        ASSIGNMENT='='
        CURL_OPEN='{'
        CURL_CLOSE='}'
        PAR_OPEN='('
        PAR_CLOSE=')'
        BRACK_OPEN='['
        BRACK_CLOSE=']'
        SMALLER_THEN='<'
        SEM_ACTION_START='(.'
        SEM_ACTION_END='.)'
        PIPE='|'
        GREATER_THEN='>'

        number='regexp:\p{Digit}+'
        ident='regexp:\p{Alpha}\p{Alnum}*'
        ANY_CHAR='regexp:.'
    ]
}

Cocol ::=
    [Imports]
    Compiler
    [GlobalFieldsAndMethods]
    ScannerSpecification
    ParserSpecification
    End

Compiler ::= "COMPILER" ident {pin=1}

Imports ::= JavaCode
//
GlobalFieldsAndMethods ::= JavaCode

private JavaCode ::= {JavaSymbols}*
ANY ::= JavaSymbols
ArbitraryText ::= (ident | string | char | number | ANY_CHAR | '.' | "out")*
ArbitraryStatements ::= {JavaSymbols}*
private JavaSymbols ::= (ident | string | char | number | ANY_CHAR | Symbols | '.' | '||' | '|' | "import" | "out") {pin(".*")=1 name = "Java Code"}

//ScannerSpecification =
// ["IGNORECASE"]
// ["CHARACTERS" {SetDecl}]
// ["TOKENS" {TokenDecl}]
// ["PRAGMAS" {PragmaDecl}]
// {CommentDecl}
// {WhiteSpaceDecl}.

ScannerSpecification ::=
    ["IGNORECASE"]
    [Characters]
    [Tokens]
    [Pragmas]
    [Comments]
    {WhiteSpaceDecl}*

Characters ::= "CHARACTERS" {SetDecl}*

SetDecl ::= ident '=' Set '.' {pin=1}

Set ::= BasicSet {('+'|'-') BasicSet}*
BasicSet ::= string | ident | char [".." char] | "ANY"

Tokens ::= "TOKENS" {TokenDecl}* {pin=1}
TokenDecl ::= Symbol [TokenAssignment]
private TokenAssignment ::= '=' TokenExpr '.' {pin=1}

TokenExpr ::= TokenTerm {TokenTermOption}* {pin=1}
private TokenTermOption ::= '|' TokenTerm {pin=1}
TokenTerm ::= TokenFactor {TokenFactor}* [TokenContext]
private TokenContext ::= "CONTEXT" '(' TokenExpr ')' {pin=1}
TokenFactor ::= Symbol
    | TokenFactor_parenthesis
    | TokenFactor_bracket
    | TokenFactor_brace

private TokenFactor_parenthesis ::= '(' TokenExpr ')' {pin=1}
private TokenFactor_bracket ::= '[' TokenExpr ']' {pin=1}
private TokenFactor_brace ::= '{' TokenExpr '}' {pin=1}
private Symbol ::= ident | string | char


Pragmas ::= "PRAGMAS" {PragmaDecl}*
PragmaDecl ::= TokenDecl [SemAction]
SemAction ::= "(." ArbitraryStatements ".)"

Comments ::= CommentDecl {CommentDecl}* {pin=1}
CommentDecl ::= "COMMENTS" "FROM" TokenExpr "TO" TokenExpr ["NESTED"]

WhiteSpaceDecl ::= "IGNORE" Set {pin=1 extends=ScannerSpecification}

ParserSpecification ::= "PRODUCTIONS" {Production}* {pin = 1}
Production ::= ident [FormalAttributes] [LocalDecl] '=' Expression '.'
Expression ::= Term {'|' Term}*
Term ::= [[Resolver] Factor {Factor}*]
Factor ::= ['WEAK'] Symbol [ActualAttributes]
    | '(' Expression ')'
    | '[' Expression ']'
    | '{' Expression '}'
| "ANY"
| "SYNC"
| SemAction
LocalDecl ::= SemAction
FormalAttributes ::= Attributes
ActualAttributes ::= Attributes
private Attributes ::= '<' ArbitraryText '>'
Resolver ::= "IF" '(' {ANY}* ')'

End ::= "END" ident '.' {pin=1}

private Symbols ::= '+' | '-'  | '=' | '(' | ')' | '<' | '>' | '{' | '}' | '[' | ']' | '..' {name = "Symbols"}
